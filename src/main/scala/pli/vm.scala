package pli

import collection.mutable
import mutable.Stack

/** Factory methods for creating [[VM virtual machines]]. */
object VM {
  /** Create a virtual machine for the given bytecode. */
  def apply(bytecode: Array[Int]): VM  =
    new VM(bytecode)

  /** Create a virtual machine for the bytecode produced by the
    * given bytecode builder. The virtual machine will be created
    * with a snapshot of the bytecode created by the bytecode
    * builder, so future operation of the bytecode builder will
    * not affect the virtual machine. */
  def apply(bytecode: Bytecode): VM =
    new VM(bytecode.result)

  /** Create a virtual machine for the bytecode produced by the
    * given code generator so far. The virtual machine will be
    * created with a snapshot of the bytecode created by the code
    * generator, so future operation of the code generator will
    * not affect the virtual machine. */
  def apply(codegen: CodeGenerator): VM =
    VM(codegen.bytecode)

  /** Create a virtual machine for the bytecode corresponding to
    * the given AST. The bytecode is generated by the
    * [[CodeGenerator code generator]]. */
  def apply(ast: ASTNode): VM = {
    val codegen = new CodeGenerator()
    codegen.generate(ast)
    codegen.bytecode.exit()
    VM(codegen)
  }
}

/** Simple virtual machine, that is, bytecode interpreter.
  *
  * To create a virtual machine, use the [[VM$ companion
  * object]]’s apply methods.
  *
  * For debugging, consider to use a [[DebugVM debug virtual
  * machine]] instead.
  *
  * 
  */
class VM(bytecode: Array[Int]) {
  /** The adress in the bytecode array to read next. */
  var codepointer = 0

  /** The virtual machine's stack. */
  var stack = Stack[Int]()

  /** Whether we are currently running. */
  var running = false

  /** Fetches next integer from the bytecode array. */
  def fetch(): Int = {
    val result = bytecode(codepointer)
    codepointer += 1
    result
  }

  /** Pushes a value to the virtual machine's stack. */
  def push(value: Int) {
    stack.push(value)
  }

  /** Pops a value from the virtual machine's stack. */
  def pop(): Int =
    stack.pop()

  /** Fetches a value from an arbitrary offset in the virtual machine's stack. */
  def get(offset: Int): Int =
    stack(offset)

  /** Stores a value at an arbitrary offset in the virtual
    * machine's stack. The value previously stored there is
    * overwritten with the given value. */
  def put(offset: Int, value: Int) {
    stack(offset) = value
  }

  /** Fetches, decodes and executes one bytecode instruction. */
  def step() {
    val base = codepointer
    val opcode = fetch()
    if (Opcode.hasParameter(opcode)) {
      val parameter = fetch()
      execute(base, opcode, parameter)
    } else {
      execute(base, opcode)
    }
  }

  /** Executes one already fetched and decoded bytecode instruction. */
  def execute(adress: Int, opcode: Int, parameter: Int = 0) {
    opcode match {
      case Opcode.iadd =>
        val rhs = pop()
        val lhs = pop()
        push(lhs + rhs)
      case Opcode.isub =>
        val rhs = pop()
        val lhs = pop()
        push(lhs - rhs)
      case Opcode.imul =>
        val rhs = pop()
        val lhs = pop()
        push(lhs * rhs)
      case Opcode.iconst =>
        push(parameter)
      case Opcode.goto =>
        codepointer = adress + parameter
      case Opcode.ifeq =>
        val condition = pop()
        if (condition == 0) {
          codepointer = adress + parameter
        }
      case Opcode.ifne =>
        val condition = pop
        if (condition != 0) {
          codepointer = adress + parameter
        }
      case Opcode.print =>
        val value = pop()
        println(value)
      case Opcode.iload =>
        push(get(parameter))
      case Opcode.istore =>
        val value = pop()
        put(parameter, value)
      case Opcode.exit =>
        running = false;
      case Opcode.pop =>
        pop()
    }
  }

  /** Fetches, decodes and executes bytecode instructions until an
    * `exit` instruction is executed. */
  def run() {
    running = true;
    while (running) {
      step()
    }
  }
}

/** A variant of the [[VM virtual machine]] that prints one line
  * of debugging output for every instruction executed.
  *
  * To create a debug virtual machine, use the [[DebugVM$
  * companion object]]’s apply methods.
  *
*/
class DebugVM(bytecode: Array[Int]) extends VM(bytecode) {
  override def execute(adress: Int, opcode: Int, parameter: Int) {
    super.execute(adress, opcode, parameter)

    val op = Opcode.toString(opcode, parameter)

    stack match {
      case Stack() =>
        println(f"$adress%02d: $op%-12s | empty stack")
      case Stack(s1) =>
        println(f"$adress%02d: $op%-12s | $s1%4d")
      case Stack(s1, s2) =>
        println(f"$adress%02d: $op%-12s | $s2%4d $s1%4d")
      case Stack(s1, s2, s3) =>
        println(f"$adress%02d: $op%-12s | $s3%4d $s2%4d $s1%4d")
      case Stack(s1, s2, s3, s4) =>
        println(f"$adress%02d: $op%-12s | $s4%4d $s3%4d $s2%4d $s1%4d")
      case Stack(s1, s2, s3, _@_*) =>
        println(f"$adress%02d: $op%-12s |  ... $s3%4d $s2%4d $s1%4d")
    }
  }
}

/** Factory methods for creating [[DebugVM debug virtual machines]]. */
object DebugVM {
  /** Create a debug virtual machine for the given bytecode. */
  def apply(bytecode: Array[Int]): VM  =
    new DebugVM(bytecode)

  /** Create a debug virtual machine for the given bytecode. The
    * virtual machine will be created with a snapshot of the
    * bytecode created by the code generator, so future operation
    * of the code generator will not affect the virtual
    * machine.*/
  def apply(bytecode: Bytecode): VM =
    new DebugVM(bytecode.result)

  /** Create a debug virtual machine for the bytecode produced by
    * the given code generator so far. The virtual machine will
    * be created with a snapshot of the bytecode created by the
    * code generator, so future operation of the code generator
    * will not affect the virtual machine. */
  def apply(codegen: CodeGenerator): VM =
    DebugVM(codegen.bytecode)

 /** Create a virtual machine for the bytecode corresponding to
    * the given AST. The bytecode is generated by the
    * [[CodeGenerator code generator]]. */
  def apply(ast: ASTNode): VM = {
    val codegen = new CodeGenerator()
    codegen.generate(ast)
    codegen.bytecode.exit()
    DebugVM(codegen)
  }
}
